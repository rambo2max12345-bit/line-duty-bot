# -*- coding: utf-8 -*-

# ========================================================================================
# ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå Server ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LINE Bot ‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏ß‡∏£ (‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô 4)
# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ñ‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ DatetimePickerAction
# ========================================================================================

from flask import Flask, request, abort

from linebot import (
    LineBotApi, WebhookHandler
)
from linebot.exceptions import (
    InvalidSignatureError
)
from linebot.models import (
    MessageEvent, TextMessage, TextSendMessage,
    QuickReply, QuickReplyButton, MessageAction,
    DatetimePickerAction # <-- ‡πÄ‡∏û‡∏¥‡πà‡∏° import ‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô
)

import os
from datetime import datetime # <-- ‡πÄ‡∏û‡∏¥‡πà‡∏° import ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà

# --- ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
CHANNEL_ACCESS_TOKEN = os.environ.get('CHANNEL_ACCESS_TOKEN', '8Qa3lq+KjkF68P1W6xAkkuRyoXpz9YyuQI2nOKJRu/ndsvfGLZIft6ltdgYV8vMEbBkz5AWzYoF+CaS7u0OShm uZvo5Yufb6+Xvr4gBti4Gc4cp45MCnyD0cte94vZyyEhLKC3WJKvd9usUXqCwrOgdB04t89/1O/w1cDnyilFU=')
CHANNEL_SECRET = os.environ.get('CHANNEL_SECRET', '1d0c51790d0bff2b98dbb98dc8f72663')
# -------------------------

app = Flask(__name__)
line_bot_api = LineBotApi(CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(CHANNEL_SECRET)

# --- ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏£‡∏∞‡∏¢‡∏∞‡∏™‡∏±‡πâ‡∏ô‡∏Ç‡∏≠‡∏á Bot (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
user_states = {}

# --- ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
personnel_list = [
    "‡∏≠‡∏™.‡∏ó‡∏û.‡∏ö‡∏∏‡∏ç‡∏ò‡∏£‡∏£‡∏° ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÄ‡∏Ç‡πá‡∏°", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏ä‡∏ô‡∏∞‡∏®‡∏±‡∏Å‡∏î‡∏¥‡πå ‡∏Å‡∏≤‡∏™‡∏±‡∏á‡∏Ç‡πå", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏™‡∏ô‡∏ò‡∏¢‡∏≤ ‡∏õ‡∏£‡∏≤‡∏ö‡∏ì‡∏£‡∏á‡∏Ñ‡πå",
    "‡∏≠‡∏™.‡∏ó‡∏û.‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£ ‡∏ô‡∏∞‡∏à‡πä‡∏∞", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏Å‡∏±‡∏°‡∏û‡∏• ‡∏ó‡∏≠‡∏á‡∏®‡∏£‡∏µ", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏≠‡∏∑‡πà‡∏ô‡πÜ"
]
# ------------------------------------

@app.route("/webhook", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    app.logger.info("Request body: " + body)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)
    return 'OK'


@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    user_id = event.source.user_id
    user_message = event.message.text

    # --- ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏ó‡∏ô‡∏≤ ---
    if user_id in user_states:
        current_step = user_states[user_id]['step']

        # ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏£‡∏≠‡∏£‡∏±‡∏ö "‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏•‡∏≤"
        if current_step == 'awaiting_leave_type':
            leave_type = user_message
            if leave_type == '#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å':
                del user_states[user_id]
                reply_message = TextSendMessage(text="‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö")
                line_bot_api.reply_message(event.reply_token, reply_message)
                return

            user_states[user_id]['data']['type'] = leave_type
            user_states[user_id]['step'] = 'awaiting_name'
            app.logger.info(f"User {user_id} selected leave type '{leave_type}'. State: {user_states[user_id]}")

            name_buttons = [QuickReplyButton(action=MessageAction(label=name, text=name)) for name in personnel_list]
            name_buttons.append(QuickReplyButton(action=MessageAction(label="‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", text="#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å")))
            
            reply_message = TextSendMessage(
                text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö",
                quick_reply=QuickReply(items=name_buttons)
            )
            line_bot_api.reply_message(event.reply_token, reply_message)
            return

        # ==============================================================================
        # ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏´‡∏°‡πà: ‡∏£‡∏≠‡∏£‡∏±‡∏ö "‡∏ä‡∏∑‡πà‡∏≠"
        # ==============================================================================
        elif current_step == 'awaiting_name':
            selected_name = user_message

            if selected_name == '#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å':
                del user_states[user_id]
                reply_message = TextSendMessage(text="‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö")
                line_bot_api.reply_message(event.reply_token, reply_message)
                return

            # 1. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
            user_states[user_id]['data']['name'] = selected_name

            # 2. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏≠‡∏£‡∏±‡∏ö "‡∏ß‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô"
            user_states[user_id]['step'] = 'awaiting_start_date'
            app.logger.info(f"User {user_id} selected name '{selected_name}'. State: {user_states[user_id]}")

            # 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡∏≠‡∏Å "‡∏ß‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô"
            # ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏õ
            today = datetime.now().strftime('%Y-%m-%d')
            date_picker_start = QuickReply(items=[
                QuickReplyButton(action=DatetimePickerAction(
                    label="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô",
                    data="action=select_start_date", # ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
                    mode="date",
                    initial=today, # ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏ö‡∏ô‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô
                    min=today      # ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏î‡πâ
                )),
                QuickReplyButton(action=MessageAction(label="‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", text="#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å"))
            ])

            # 4. ‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏õ
            reply_message = TextSendMessage(
                text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏•‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö",
                quick_reply=date_picker_start
            )
            line_bot_api.reply_message(event.reply_token, reply_message)
            return
        # ==============================================================================

    # --- ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
    if user_message == '#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å':
        if user_id in user_states:
            del user_states[user_id]
            reply_message = TextSendMessage(text="‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö")
            line_bot_api.reply_message(event.reply_token, reply_message)
        return

    if user_message == '#Bot01':
        quick_reply_buttons = QuickReply(items=[
            QuickReplyButton(action=MessageAction(label="üìù ‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤/‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£", text="#‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤")),
            QuickReplyButton(action=MessageAction(label="üóìÔ∏è ‡∏à‡∏±‡∏î‡πÄ‡∏ß‡∏£‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô", text="#‡∏à‡∏±‡∏î‡πÄ‡∏ß‡∏£")),
            QuickReplyButton(action=MessageAction(label="üìÑ ‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏•‡∏≤", text="#‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏≤"))
        ])
        reply_message = TextSendMessage(
            text="‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏Ñ‡∏£‡∏±‡∏ö‡∏ô‡∏≤‡∏¢‡∏ó‡πà‡∏≤‡∏ô",
            quick_reply=quick_reply_buttons
        )
        line_bot_api.reply_message(event.reply_token, reply_message)

    elif user_message == '#‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤':
        user_states[user_id] = {'step': 'awaiting_leave_type', 'data': {}}
        app.logger.info(f"User {user_id} started leave process. Current states: {user_states}")
        leave_type_buttons = QuickReply(items=[
            QuickReplyButton(action=MessageAction(label="‡∏•‡∏≤‡∏û‡∏±‡∏Å", text="‡∏•‡∏≤‡∏û‡∏±‡∏Å")),
            QuickReplyButton(action=MessageAction(label="‡∏•‡∏≤‡∏Å‡∏¥‡∏à", text="‡∏•‡∏≤‡∏Å‡∏¥‡∏à")),
            QuickReplyButton(action=MessageAction(label="‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢", text="‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢")),
            QuickReplyButton(action=MessageAction(label="‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£", text="‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£")),
            QuickReplyButton(action=MessageAction(label="‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", text="#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å"))
        ])
        reply_message = TextSendMessage(
            text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö",
            quick_reply=leave_type_buttons
        )
        line_bot_api.reply_message(event.reply_token, reply_message)


# ‡∏™‡πà‡∏ß‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏±‡∏ô Server
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))
    app.run(host='0.0.0.0', port=port)

