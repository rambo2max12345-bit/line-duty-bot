# -*- coding: utf-8 -*-

# ========================================================================================
# ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå Server ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö LINE Bot ‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏ß‡∏£ (‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô 6 - ‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå)
# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏ß‡∏±‡∏ô‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î, ‡∏™‡∏£‡∏∏‡∏õ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•, ‡πÅ‡∏•‡∏∞‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£
# ========================================================================================

from flask import Flask, request, abort

from linebot import (
    LineBotApi, WebhookHandler
)
from linebot.exceptions import (
    InvalidSignatureError
)
from linebot.models import (
    MessageEvent, TextMessage, TextSendMessage,
    QuickReply, QuickReplyButton, MessageAction,
    DatetimePickerAction,
    PostbackEvent
)

import os
from datetime import datetime

# --- ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
CHANNEL_ACCESS_TOKEN = os.environ.get('CHANNEL_ACCESS_TOKEN', '8Qa3lq+KjkF68P1W6xAkkuRyoXpz9YyuQI2nOKJRu/ndsvfGLZIft6ltdgYV8vMEbBkz5AWzYoF+CaS7u0OShm uZvo5Yufb6+Xvr4gBti4Gc4cp45MCnyD0cte94vZyyEhLKC3WJKvd9usUXqCwrOgdB04t89/1O/w1cDnyilFU=')
CHANNEL_SECRET = os.environ.get('CHANNEL_SECRET', '1d0c51790d0bff2b98dbb98dc8f72663')
# -------------------------

app = Flask(__name__)
line_bot_api = LineBotApi(CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(CHANNEL_SECRET)

# --- ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏£‡∏∞‡∏¢‡∏∞‡∏™‡∏±‡πâ‡∏ô‡∏Ç‡∏≠‡∏á Bot (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
user_states = {}

# --- ‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
personnel_list = [
    "‡∏≠‡∏™.‡∏ó‡∏û.‡∏ö‡∏∏‡∏ç‡∏ò‡∏£‡∏£‡∏° ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÄ‡∏Ç‡πá‡∏°", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏ä‡∏ô‡∏∞‡∏®‡∏±‡∏Å‡∏î‡∏¥‡πå ‡∏Å‡∏≤‡∏™‡∏±‡∏á‡∏Ç‡πå", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏™‡∏ô‡∏ò‡∏¢‡∏≤ ‡∏õ‡∏£‡∏≤‡∏ö‡∏ì‡∏£‡∏á‡∏Ñ‡πå",
    "‡∏≠‡∏™.‡∏ó‡∏û.‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£ ‡∏ô‡∏∞‡∏à‡πä‡∏∞", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏Å‡∏±‡∏°‡∏û‡∏• ‡∏ó‡∏≠‡∏á‡∏®‡∏£‡∏µ", "‡∏≠‡∏™.‡∏ó‡∏û.‡∏≠‡∏∑‡πà‡∏ô‡πÜ"
]
# ------------------------------------

@app.route("/webhook", methods=['POST'])
def callback():
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    app.logger.info("Request body: " + body)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)
    return 'OK'


@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö "‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£" ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    user_id = event.source.user_id
    user_message = event.message.text

    if user_id in user_states:
        current_step = user_states[user_id]['step']
        # ... (‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î) ...
        if current_step == 'awaiting_leave_type':
            leave_type = user_message
            if leave_type == '#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å':
                del user_states[user_id]
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö"))
                return
            user_states[user_id]['data']['type'] = leave_type
            user_states[user_id]['step'] = 'awaiting_name'
            name_buttons = [QuickReplyButton(action=MessageAction(label=name, text=name)) for name in personnel_list]
            name_buttons.append(QuickReplyButton(action=MessageAction(label="‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", text="#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å")))
            reply_message = TextSendMessage(text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö", quick_reply=QuickReply(items=name_buttons))
            line_bot_api.reply_message(event.reply_token, reply_message)
            return

        elif current_step == 'awaiting_name':
            selected_name = user_message
            if selected_name == '#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å':
                del user_states[user_id]
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö"))
                return
            user_states[user_id]['data']['name'] = selected_name
            user_states[user_id]['step'] = 'awaiting_start_date'
            today = datetime.now().strftime('%Y-%m-%d')
            date_picker_start = QuickReply(items=[
                QuickReplyButton(action=DatetimePickerAction(label="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô", data="action=select_start_date", mode="date", initial=today, min=today)),
                QuickReplyButton(action=MessageAction(label="‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", text="#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å"))
            ])
            reply_message = TextSendMessage(text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏•‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö", quick_reply=date_picker_start)
            line_bot_api.reply_message(event.reply_token, reply_message)
            return

    # --- ‡∏™‡πà‡∏ß‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ---
    if user_message == '#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å':
        if user_id in user_states:
            del user_states[user_id]
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text="‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö"))
        return

    if user_message == '#Bot01':
        quick_reply_buttons = QuickReply(items=[
            QuickReplyButton(action=MessageAction(label="üìù ‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤/‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£", text="#‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤")),
            QuickReplyButton(action=MessageAction(label="üóìÔ∏è ‡∏à‡∏±‡∏î‡πÄ‡∏ß‡∏£‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô", text="#‡∏à‡∏±‡∏î‡πÄ‡∏ß‡∏£")),
            QuickReplyButton(action=MessageAction(label="üìÑ ‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏•‡∏≤", text="#‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏≤"))
        ])
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text="‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏Ñ‡∏£‡∏±‡∏ö‡∏ô‡∏≤‡∏¢‡∏ó‡πà‡∏≤‡∏ô", quick_reply=quick_reply_buttons))

    elif user_message == '#‡πÅ‡∏à‡πâ‡∏á‡∏•‡∏≤':
        user_states[user_id] = {'step': 'awaiting_leave_type', 'data': {}}
        leave_type_buttons = QuickReply(items=[
            QuickReplyButton(action=MessageAction(label="‡∏•‡∏≤‡∏û‡∏±‡∏Å", text="‡∏•‡∏≤‡∏û‡∏±‡∏Å")),
            QuickReplyButton(action=MessageAction(label="‡∏•‡∏≤‡∏Å‡∏¥‡∏à", text="‡∏•‡∏≤‡∏Å‡∏¥‡∏à")),
            QuickReplyButton(action=MessageAction(label="‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢", text="‡∏•‡∏≤‡∏õ‡πà‡∏ß‡∏¢")),
            QuickReplyButton(action=MessageAction(label="‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£", text="‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£")),
            QuickReplyButton(action=MessageAction(label="‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", text="#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å"))
        ])
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö", quick_reply=leave_type_buttons))


@handler.add(PostbackEvent)
def handle_postback(event):
    # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏à‡∏≤‡∏Å‡∏õ‡∏è‡∏¥‡∏ó‡∏¥‡∏ô
    user_id = event.source.user_id
    postback_data = event.postback.data

    if user_id in user_states:
        current_step = user_states[user_id]['step']

        if current_step == 'awaiting_start_date' and postback_data == 'action=select_start_date':
            # ... (‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°) ...
            selected_date = event.postback.params['date']
            user_states[user_id]['data']['start_date'] = selected_date
            user_states[user_id]['step'] = 'awaiting_end_date'
            date_picker_end = QuickReply(items=[
                QuickReplyButton(action=DatetimePickerAction(label="‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î", data="action=select_end_date", mode="date", initial=selected_date, min=selected_date)),
                QuickReplyButton(action=MessageAction(label="‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", text="#‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å"))
            ])
            reply_message = TextSendMessage(text="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏±‡∏ô‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Ñ‡∏£‡∏±‡∏ö", quick_reply=date_picker_end)
            line_bot_api.reply_message(event.reply_token, reply_message)
            return
        
        # ==============================================================================
        # ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏´‡∏°‡πà: ‡∏£‡∏≠‡∏£‡∏±‡∏ö "‡∏ß‡∏±‡∏ô‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î"
        # ==============================================================================
        elif current_step == 'awaiting_end_date' and postback_data == 'action=select_end_date':
            selected_end_date = event.postback.params['date']
            
            # 1. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡∏±‡∏ô‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î
            user_states[user_id]['data']['end_date'] = selected_end_date
            app.logger.info(f"User {user_id} selected end date '{selected_end_date}'. Final data: {user_states[user_id]['data']}")
            
            # 2. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡∏°‡∏≤
            final_data = user_states[user_id]['data']
            
            # 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏£‡∏∏‡∏õ
            # (‡πÅ‡∏õ‡∏•‡∏á YYYY-MM-DD ‡πÄ‡∏õ‡πá‡∏ô DD/MM/YYYY)
            start_date_formatted = datetime.strptime(final_data['start_date'], '%Y-%m-%d').strftime('%d/%m/%Y')
            end_date_formatted = datetime.strptime(final_data['end_date'], '%Y-%m-%d').strftime('%d/%m/%Y')
            
            summary_message = (
                "‚úÖ **‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢**\n\n"
                f"**‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó:** {final_data['type']}\n"
                f"**‡∏ä‡∏∑‡πà‡∏≠:** {final_data['name']}\n"
                f"**‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà:** {start_date_formatted}\n"
                f"**‡∏ñ‡∏∂‡∏á:** {end_date_formatted}"
            )
            
            # 4. ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
            # (‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á Firebase ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ)
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=summary_message))
            
            # 5. ‡∏•‡πâ‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ô‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥ ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏ö‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£
            del user_states[user_id]
            return
        # ==============================================================================

# ‡∏™‡πà‡∏ß‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏±‡∏ô Server
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))
    app.run(host='0.0.0.0', port=port)

